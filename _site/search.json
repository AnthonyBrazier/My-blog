[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My-Blog",
    "section": "",
    "text": "Atividade 2 - API SPTRANS\n\n\n\nAPI\n\nPYTHON\n\nCODE\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAnthony Brazier Leite\n\n\n\n\n\n\n\n\n\n\n\n\nAtividade 1 - Cotação Dolar\n\n\n\nJSON\n\nPYTHON\n\nCODE\n\nGRÁFICO\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAnthony Brazier Leite\n\n\n\n\n\n\n\n\n\n\n\n\nAtividade 3 - Regressão Linear\n\n\n\nLINEAR\n\nPYTHON\n\nCODE\n\nGRÁFICO\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nAnthony Brazier Leite\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Atividade 1 - Cotação Dolar",
    "section": "",
    "text": "Neste Post eu mostro uma forma em python de fazer uma pesquisa em um site onde apareçe informações das cotações do dolar em uma determinada época em forma de gráfico.\n\nimport pandas as pd\nimport requests\nimport calendar\nfrom datetime import datetime\nimport plotly.express as px\n\ndef cotacao(mmyyyy: str):\n    \"\"\"\n    Recebe uma string no formato 'MMYYYY' e retorna\n    um gráfico de linha com as cotações diárias do dólar PTAX.\n    \"\"\"\n\n    first_date = datetime.strptime(mmyyyy, \"%m%Y\")\n    last_date = first_date.replace(\n        day = calendar.monthrange(first_date.year, first_date.month)[1]\n    )\n\n    # Converter para: mm-dd-yyyy\n    data_inicial = first_date.strftime(\"%m-%d-%Y\")\n    data_final = last_date.strftime(\"%m-%d-%Y\")\n\n    # 2  URL da API\n    url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        \"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n        f\"?@dataInicial='{data_inicial}'&@dataFinalCotacao='{data_final}'\"\n        \"&$top=100&$format=json\"\n    )\n\n    # Puxa pela URL\n    response = requests.get(url)\n    dados = response.json()[\"value\"]\n\n    # Cria DataFrame\n    df = pd.DataFrame(dados)\n    df[\"data\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n    df = df[[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"]]\n\n    # Remove duplicados e ordena\n    df = df.groupby(\"data\").mean().reset_index()\n    df = df.sort_values(\"data\")\n\n    # Feriados e finais de semana \n    idx = pd.date_range(start=first_date, end=last_date)\n    df = df.set_index(\"data\").reindex(idx)\n    df = df.fillna(method=\"ffill\")\n    df.index.name = \"data\"\n    df = df.reset_index()\n\n    # Plotly\n    fig = px.line(\n        df,\n        x=\"data\",\n        y=\"cotacaoVenda\",\n        title=f\"Cotação do Dólar  {mmyyyy[:2]}/{mmyyyy[2:]}\",\n        labels={\"cotacaoVenda\": \"Cotação (Venda)\", \"data\": \"Data\"}\n    )\n\n    fig.update_layout(yaxis_tickformat=\".2f\")\n    return fig\n\n# Escolha da data\n\ncotacao(\"042013\")\n\n/tmp/ipykernel_29969/2048383747.py:46: FutureWarning:\n\nDataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/onibus/index.html",
    "href": "posts/onibus/index.html",
    "title": "Atividade 2 - API SPTRANS",
    "section": "",
    "text": "Neste Post eu mostro uma forma em python utilizando de uma API do SPTRANS para mostrar as paradas e os veículos de uma determinada linha.\n\nimport os\nimport requests\nfrom dotenv import load_dotenv\nfrom IPython.display import HTML, display\nimport folium\nimport math\n\nload_dotenv()\ntoken = os.getenv(\"SPTRANS_TOKEN\")\n\ns = requests.Session()\n\ndef fetch_paradas_pos(codigo_linha=2506):\n    \"\"\"Tenta buscar paradas e posições da API; retorna (paradas, pos_list).\n    Em caso de erro ou token ausente, retorna dados de demonstração.\"\"\"\n    if not token:\n        print(\"SPTRANS_TOKEN não encontrado — usando dados de demonstração.\")\n        return demo_paradas, demo_pos\n\n    try:\n        # Verificação do token\n        auth = s.post(f\"https://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={token}\", timeout=10)\n        print(\"Login response:\", auth.text)\n\n        # Busca paradas da linha\n        r_par = s.get(f\"https://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha={codigo_linha}\", timeout=10)\n        paradas = r_par.json()\n\n        # Busca posições dos veículos\n\n        r_pos = s.get(f\"https://api.olhovivo.sptrans.com.br/v2.1/Posicao/Linha?codigoLinha={codigo_linha}\", timeout=10)\n        pos_json = r_pos.json()\n        pos_list = pos_json.get(\"vs\") if isinstance(pos_json, dict) else []\n\n        if not paradas:\n            print(\"API retornou 0 paradas — usando dados de demonstração.\")\n            return demo_paradas, demo_pos\n\n        return paradas, pos_list\n\n    except Exception as e:\n        print(\"Erro ao acessar API Olho Vivo:\", e)\n        print(\"Usando dados de demonstração.\")\n        return demo_paradas, demo_pos\n\n\nparadas, pos_list = fetch_paradas_pos(codigo_linha=2506)\n\nprint(f\"Usando {len(paradas)} paradas e {len(pos_list)} posições (veículos).\")\n\n# Coloca o mapa no centro da cidade\n\ndef mean_center(points):\n    lat = [p[\"py\"] for p in points]\n    lon = [p[\"px\"] for p in points]\n    return (sum(lat) / len(lat), sum(lon) / len(lon))\n\ncenter = mean_center(paradas) if paradas else (-23.534564, -46.654302)\n\n# Construi mapa\n\nm = folium.Map(location=center, zoom_start=14)\n\nfor p in paradas:\n    folium.Marker(location=[p[\"py\"], p[\"px\"]], popup=f\"{p.get('np')}\\n{p.get('ed','')}\").add_to(m)\n\n# Adiciona veículos\n\nfor v in pos_list:\n    try:\n        folium.CircleMarker(location=[v[\"py\"], v[\"px\"]], radius=6, color=\"red\", fill=True, fill_opacity=0.8,\n                            popup=f\"Veículo: {v.get('p')}\\nHora: {v.get('ta')}\").add_to(m)\n    except Exception:\n        pass\n\n# Salva no HTML\n\noutput = f\"paradas_linha.html\"\nm.save(output)\nprint(f\"Mapa salvo em: {output}\")\n\n# Mostra o mapa pelo quarto\n\ndisplay(HTML(m._repr_html_()))\n\nLogin response: true\nUsando 15 paradas e 3 posições (veículos).\nMapa salvo em: paradas_linha.html\n\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "posts/dolar/index.html",
    "href": "posts/dolar/index.html",
    "title": "Atividade 1 - Cotação Dolar",
    "section": "",
    "text": "Neste Post eu mostro uma forma em python de fazer uma pesquisa em um site onde apareçe informações das cotações do dolar em uma determinada época em forma de gráfico.\n\nimport pandas as pd\nimport requests\nimport calendar\nfrom datetime import datetime\nimport plotly.express as px\n\ndef cotacao(mmyyyy: str):\n    \"\"\"\n    Recebe uma string no formato 'MMYYYY' e retorna\n    um gráfico de linha com as cotações diárias do dólar PTAX.\n    \"\"\"\n\n    first_date = datetime.strptime(mmyyyy, \"%m%Y\")\n    last_date = first_date.replace(\n        day = calendar.monthrange(first_date.year, first_date.month)[1]\n    )\n\n    # Converter para: mm-dd-yyyy\n    data_inicial = first_date.strftime(\"%m-%d-%Y\")\n    data_final = last_date.strftime(\"%m-%d-%Y\")\n\n    # 2  URL da API\n    url = (\n        \"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        \"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)\"\n        f\"?@dataInicial='{data_inicial}'&@dataFinalCotacao='{data_final}'\"\n        \"&$top=100&$format=json\"\n    )\n\n    # Puxa pela URL\n    response = requests.get(url)\n    dados = response.json()[\"value\"]\n\n    # Cria DataFrame\n    df = pd.DataFrame(dados)\n    df[\"data\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n    df = df[[\"data\", \"cotacaoCompra\", \"cotacaoVenda\"]]\n\n    # Remove duplicados e ordena\n    df = df.groupby(\"data\").mean().reset_index()\n    df = df.sort_values(\"data\")\n\n    # Feriados e finais de semana \n    idx = pd.date_range(start=first_date, end=last_date)\n    df = df.set_index(\"data\").reindex(idx)\n    df = df.fillna(method=\"ffill\")\n    df.index.name = \"data\"\n    df = df.reset_index()\n\n    # Plotly\n    fig = px.line(\n        df,\n        x=\"data\",\n        y=\"cotacaoVenda\",\n        title=f\"Cotação do Dólar  {mmyyyy[:2]}/{mmyyyy[2:]}\",\n        labels={\"cotacaoVenda\": \"Cotação (Venda)\", \"data\": \"Data\"}\n    )\n\n    fig.update_layout(yaxis_tickformat=\".2f\")\n    return fig\n\n# Escolha da data\n\ncotacao(\"042013\")\n\n/tmp/ipykernel_35758/2048383747.py:46: FutureWarning:\n\nDataFrame.fillna with 'method' is deprecated and will raise in a future version. Use obj.ffill() or obj.bfill() instead."
  },
  {
    "objectID": "posts/linear/index.html",
    "href": "posts/linear/index.html",
    "title": "Atividade 3 - Regressão Linear",
    "section": "",
    "text": "Neste Post eu mostro uma forma em python para calcular a regressão linar de x e y.\nimport os import numpy as np import pandas as pd import matplotlib.pyplot as plt from plotnine import ggplot, aes, geom_point, geom_abline, ggsave from IPython.display import Image, display\n\nCaminhos dos arquivos\nX_path = “/mnt/data/X.txt” y_path = “/mnt/data/y.txt”\nprint(“CWD:”, os.getcwd()) print(“X.txt exists:”, os.path.exists(X_path)) print(“y.txt exists:”, os.path.exists(y_path))\n\n\nLeitura dos dados\nif os.path.exists(X_path) and os.path.exists(y_path):\nX_path = os.path.join(os.getcwd(), 'X.txt')\ny_path = os.path.join(os.getcwd(), 'y.txt')\n\nprint('CWD:', os.getcwd())\nprint('X.txt exists:', os.path.exists(X_path))\nprint('y.txt exists:', os.path.exists(y_path))\n\n# Carregar dados \n\nif os.path.exists(X_path) and os.path.exists(y_path):\n    X = np.loadtxt(X_path)\n    y = np.loadtxt(y_path)\nelse:\n    print('Arquivos não encontrados — usando valores constantes fornecidos.')\n    X = np.full(50, 4.6317925681770316)\n    y = np.full_like(X, 12439.153947498304)\n\nX = np.asarray(X).ravel()\ny = np.asarray(y).ravel()\n\nprint('shapes:', X.shape, y.shape)\n\n# Estima regressão\n\nif np.isclose(np.var(X), 0):\n    intercepto = float(np.mean(y))\n    inclinacao = 0.0\nelse:\n    X_mat = np.vstack([np.ones_like(X), X]).T\n    beta = np.linalg.lstsq(X_mat, y, rcond=None)[0]\n    intercepto, inclinacao = float(beta[0]), float(beta[1])\n\n# Plot com matplotlib\n\ndf = pd.DataFrame({'x': X, 'y': y})\nfig, ax = plt.subplots(figsize=(8, 4.5))\nax.scatter(df['x'], df['y'], color='tab:blue', label='Dados')\nx_line = np.linspace(df['x'].min(), df['x'].max(), 200)\nax.plot(x_line, intercepto + inclinacao * x_line, color='red', label='Ajuste linear')\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\nfig.tight_layout()\nfig.savefig('grafico_regressao.png', dpi=150)\ndisplay(Image('grafico_regressao.png'))\n\nprint(f'Intercepto: {intercepto:.4f}')\nprint(f'Inclinação: {inclinacao:.4f}')\n```\n\n\n\nGráfico de regressão"
  }
]